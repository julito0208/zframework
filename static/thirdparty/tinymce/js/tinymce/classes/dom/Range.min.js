
define("tinymce/dom/Range",["tinymce/util/Tools"],function(Tools){function Range(dom){var self=this,doc=dom.doc,EXTRACT=0,CLONE=1,DELETE=2,TRUE=true,FALSE=false,START_OFFSET='startOffset',START_CONTAINER='startContainer',END_CONTAINER='endContainer',END_OFFSET='endOffset',extend=Tools.extend,nodeIndex=dom.nodeIndex;function createDocumentFragment(){return doc.createDocumentFragment();}
function setStart(n,o){_setEndPoint(TRUE,n,o);}
function setEnd(n,o){_setEndPoint(FALSE,n,o);}
function setStartBefore(n){setStart(n.parentNode,nodeIndex(n));}
function setStartAfter(n){setStart(n.parentNode,nodeIndex(n)+1);}
function setEndBefore(n){setEnd(n.parentNode,nodeIndex(n));}
function setEndAfter(n){setEnd(n.parentNode,nodeIndex(n)+1);}
function collapse(ts){if(ts){self[END_CONTAINER]=self[START_CONTAINER];self[END_OFFSET]=self[START_OFFSET];}else{self[START_CONTAINER]=self[END_CONTAINER];self[START_OFFSET]=self[END_OFFSET];}
self.collapsed=TRUE;}
function selectNode(n){setStartBefore(n);setEndAfter(n);}
function selectNodeContents(n){setStart(n,0);setEnd(n,n.nodeType===1?n.childNodes.length:n.nodeValue.length);}
function compareBoundaryPoints(h,r){var sc=self[START_CONTAINER],so=self[START_OFFSET],ec=self[END_CONTAINER],eo=self[END_OFFSET],rsc=r.startContainer,rso=r.startOffset,rec=r.endContainer,reo=r.endOffset;if(h===0){return _compareBoundaryPoints(sc,so,rsc,rso);}
if(h===1){return _compareBoundaryPoints(ec,eo,rsc,rso);}
if(h===2){return _compareBoundaryPoints(ec,eo,rec,reo);}
if(h===3){return _compareBoundaryPoints(sc,so,rec,reo);}}
function deleteContents(){_traverse(DELETE);}
function extractContents(){return _traverse(EXTRACT);}
function cloneContents(){return _traverse(CLONE);}
function insertNode(n){var startContainer=this[START_CONTAINER],startOffset=this[START_OFFSET],nn,o;if((startContainer.nodeType===3||startContainer.nodeType===4)&&startContainer.nodeValue){if(!startOffset){startContainer.parentNode.insertBefore(n,startContainer);}else if(startOffset>=startContainer.nodeValue.length){dom.insertAfter(n,startContainer);}else{nn=startContainer.splitText(startOffset);startContainer.parentNode.insertBefore(n,nn);}}else{if(startContainer.childNodes.length>0){o=startContainer.childNodes[startOffset];}
if(o){startContainer.insertBefore(n,o);}else{if(startContainer.nodeType==3){dom.insertAfter(n,startContainer);}else{startContainer.appendChild(n);}}}}
function surroundContents(n){var f=self.extractContents();self.insertNode(n);n.appendChild(f);self.selectNode(n);}
function cloneRange(){return extend(new Range(dom),{startContainer:self[START_CONTAINER],startOffset:self[START_OFFSET],endContainer:self[END_CONTAINER],endOffset:self[END_OFFSET],collapsed:self.collapsed,commonAncestorContainer:self.commonAncestorContainer});}
function _getSelectedNode(container,offset){var child;if(container.nodeType==3){return container;}
if(offset<0){return container;}
child=container.firstChild;while(child&&offset>0){--offset;child=child.nextSibling;}
if(child){return child;}
return container;}
function _isCollapsed(){return(self[START_CONTAINER]==self[END_CONTAINER]&&self[START_OFFSET]==self[END_OFFSET]);}
function _compareBoundaryPoints(containerA,offsetA,containerB,offsetB){var c,offsetC,n,cmnRoot,childA,childB;if(containerA==containerB){if(offsetA==offsetB){return 0;}
if(offsetA<offsetB){return-1;}
return 1;}
c=containerB;while(c&&c.parentNode!=containerA){c=c.parentNode;}
if(c){offsetC=0;n=containerA.firstChild;while(n!=c&&offsetC<offsetA){offsetC++;n=n.nextSibling;}
if(offsetA<=offsetC){return-1;}
return 1;}
c=containerA;while(c&&c.parentNode!=containerB){c=c.parentNode;}
if(c){offsetC=0;n=containerB.firstChild;while(n!=c&&offsetC<offsetB){offsetC++;n=n.nextSibling;}
if(offsetC<offsetB){return-1;}
return 1;}
cmnRoot=dom.findCommonAncestor(containerA,containerB);childA=containerA;while(childA&&childA.parentNode!=cmnRoot){childA=childA.parentNode;}
if(!childA){childA=cmnRoot;}
childB=containerB;while(childB&&childB.parentNode!=cmnRoot){childB=childB.parentNode;}
if(!childB){childB=cmnRoot;}
if(childA==childB){return 0;}
n=cmnRoot.firstChild;while(n){if(n==childA){return-1;}
if(n==childB){return 1;}
n=n.nextSibling;}}
function _setEndPoint(st,n,o){var ec,sc;if(st){self[START_CONTAINER]=n;self[START_OFFSET]=o;}else{self[END_CONTAINER]=n;self[END_OFFSET]=o;}
ec=self[END_CONTAINER];while(ec.parentNode){ec=ec.parentNode;}
sc=self[START_CONTAINER];while(sc.parentNode){sc=sc.parentNode;}
if(sc==ec){if(_compareBoundaryPoints(self[START_CONTAINER],self[START_OFFSET],self[END_CONTAINER],self[END_OFFSET])>0){self.collapse(st);}}else{self.collapse(st);}
self.collapsed=_isCollapsed();self.commonAncestorContainer=dom.findCommonAncestor(self[START_CONTAINER],self[END_CONTAINER]);}
function _traverse(how){var c,endContainerDepth=0,startContainerDepth=0,p,depthDiff,startNode,endNode,sp,ep;if(self[START_CONTAINER]==self[END_CONTAINER]){return _traverseSameContainer(how);}
for(c=self[END_CONTAINER],p=c.parentNode;p;c=p,p=p.parentNode){if(p==self[START_CONTAINER]){return _traverseCommonStartContainer(c,how);}
++endContainerDepth;}
for(c=self[START_CONTAINER],p=c.parentNode;p;c=p,p=p.parentNode){if(p==self[END_CONTAINER]){return _traverseCommonEndContainer(c,how);}
++startContainerDepth;}
depthDiff=startContainerDepth-endContainerDepth;startNode=self[START_CONTAINER];while(depthDiff>0){startNode=startNode.parentNode;depthDiff--;}
endNode=self[END_CONTAINER];while(depthDiff<0){endNode=endNode.parentNode;depthDiff++;}
for(sp=startNode.parentNode,ep=endNode.parentNode;sp!=ep;sp=sp.parentNode,ep=ep.parentNode){startNode=sp;endNode=ep;}
return _traverseCommonAncestors(startNode,endNode,how);}
function _traverseSameContainer(how){var frag,s,sub,n,cnt,sibling,xferNode,start,len;if(how!=DELETE){frag=createDocumentFragment();}
if(self[START_OFFSET]==self[END_OFFSET]){return frag;}
if(self[START_CONTAINER].nodeType==3){s=self[START_CONTAINER].nodeValue;sub=s.substring(self[START_OFFSET],self[END_OFFSET]);if(how!=CLONE){n=self[START_CONTAINER];start=self[START_OFFSET];len=self[END_OFFSET]-self[START_OFFSET];if(start===0&&len>=n.nodeValue.length-1){n.parentNode.removeChild(n);}else{n.deleteData(start,len);}
self.collapse(TRUE);}
if(how==DELETE){return;}
if(sub.length>0){frag.appendChild(doc.createTextNode(sub));}
return frag;}
n=_getSelectedNode(self[START_CONTAINER],self[START_OFFSET]);cnt=self[END_OFFSET]-self[START_OFFSET];while(n&&cnt>0){sibling=n.nextSibling;xferNode=_traverseFullySelected(n,how);if(frag){frag.appendChild(xferNode);}
--cnt;n=sibling;}
if(how!=CLONE){self.collapse(TRUE);}
return frag;}
function _traverseCommonStartContainer(endAncestor,how){var frag,n,endIdx,cnt,sibling,xferNode;if(how!=DELETE){frag=createDocumentFragment();}
n=_traverseRightBoundary(endAncestor,how);if(frag){frag.appendChild(n);}
endIdx=nodeIndex(endAncestor);cnt=endIdx-self[START_OFFSET];if(cnt<=0){if(how!=CLONE){self.setEndBefore(endAncestor);self.collapse(FALSE);}
return frag;}
n=endAncestor.previousSibling;while(cnt>0){sibling=n.previousSibling;xferNode=_traverseFullySelected(n,how);if(frag){frag.insertBefore(xferNode,frag.firstChild);}
--cnt;n=sibling;}
if(how!=CLONE){self.setEndBefore(endAncestor);self.collapse(FALSE);}
return frag;}
function _traverseCommonEndContainer(startAncestor,how){var frag,startIdx,n,cnt,sibling,xferNode;if(how!=DELETE){frag=createDocumentFragment();}
n=_traverseLeftBoundary(startAncestor,how);if(frag){frag.appendChild(n);}
startIdx=nodeIndex(startAncestor);++startIdx;cnt=self[END_OFFSET]-startIdx;n=startAncestor.nextSibling;while(n&&cnt>0){sibling=n.nextSibling;xferNode=_traverseFullySelected(n,how);if(frag){frag.appendChild(xferNode);}
--cnt;n=sibling;}
if(how!=CLONE){self.setStartAfter(startAncestor);self.collapse(TRUE);}
return frag;}
function _traverseCommonAncestors(startAncestor,endAncestor,how){var n,frag,startOffset,endOffset,cnt,sibling,nextSibling;if(how!=DELETE){frag=createDocumentFragment();}
n=_traverseLeftBoundary(startAncestor,how);if(frag){frag.appendChild(n);}
startOffset=nodeIndex(startAncestor);endOffset=nodeIndex(endAncestor);++startOffset;cnt=endOffset-startOffset;sibling=startAncestor.nextSibling;while(cnt>0){nextSibling=sibling.nextSibling;n=_traverseFullySelected(sibling,how);if(frag){frag.appendChild(n);}
sibling=nextSibling;--cnt;}
n=_traverseRightBoundary(endAncestor,how);if(frag){frag.appendChild(n);}
if(how!=CLONE){self.setStartAfter(startAncestor);self.collapse(TRUE);}
return frag;}
function _traverseRightBoundary(root,how){var next=_getSelectedNode(self[END_CONTAINER],self[END_OFFSET]-1),parent,clonedParent;var prevSibling,clonedChild,clonedGrandParent,isFullySelected=next!=self[END_CONTAINER];if(next==root){return _traverseNode(next,isFullySelected,FALSE,how);}
parent=next.parentNode;clonedParent=_traverseNode(parent,FALSE,FALSE,how);while(parent){while(next){prevSibling=next.previousSibling;clonedChild=_traverseNode(next,isFullySelected,FALSE,how);if(how!=DELETE){clonedParent.insertBefore(clonedChild,clonedParent.firstChild);}
isFullySelected=TRUE;next=prevSibling;}
if(parent==root){return clonedParent;}
next=parent.previousSibling;parent=parent.parentNode;clonedGrandParent=_traverseNode(parent,FALSE,FALSE,how);if(how!=DELETE){clonedGrandParent.appendChild(clonedParent);}
clonedParent=clonedGrandParent;}}
function _traverseLeftBoundary(root,how){var next=_getSelectedNode(self[START_CONTAINER],self[START_OFFSET]),isFullySelected=next!=self[START_CONTAINER];var parent,clonedParent,nextSibling,clonedChild,clonedGrandParent;if(next==root){return _traverseNode(next,isFullySelected,TRUE,how);}
parent=next.parentNode;clonedParent=_traverseNode(parent,FALSE,TRUE,how);while(parent){while(next){nextSibling=next.nextSibling;clonedChild=_traverseNode(next,isFullySelected,TRUE,how);if(how!=DELETE){clonedParent.appendChild(clonedChild);}
isFullySelected=TRUE;next=nextSibling;}
if(parent==root){return clonedParent;}
next=parent.nextSibling;parent=parent.parentNode;clonedGrandParent=_traverseNode(parent,FALSE,TRUE,how);if(how!=DELETE){clonedGrandParent.appendChild(clonedParent);}
clonedParent=clonedGrandParent;}}
function _traverseNode(n,isFullySelected,isLeft,how){var txtValue,newNodeValue,oldNodeValue,offset,newNode;if(isFullySelected){return _traverseFullySelected(n,how);}
if(n.nodeType==3){txtValue=n.nodeValue;if(isLeft){offset=self[START_OFFSET];newNodeValue=txtValue.substring(offset);oldNodeValue=txtValue.substring(0,offset);}else{offset=self[END_OFFSET];newNodeValue=txtValue.substring(0,offset);oldNodeValue=txtValue.substring(offset);}
if(how!=CLONE){n.nodeValue=oldNodeValue;}
if(how==DELETE){return;}
newNode=dom.clone(n,FALSE);newNode.nodeValue=newNodeValue;return newNode;}
if(how==DELETE){return;}
return dom.clone(n,FALSE);}
function _traverseFullySelected(n,how){if(how!=DELETE){return how==CLONE?dom.clone(n,TRUE):n;}
n.parentNode.removeChild(n);}
function toStringIE(){return dom.create('body',null,cloneContents()).outerText;}
extend(self,{startContainer:doc,startOffset:0,endContainer:doc,endOffset:0,collapsed:TRUE,commonAncestorContainer:doc,START_TO_START:0,START_TO_END:1,END_TO_END:2,END_TO_START:3,setStart:setStart,setEnd:setEnd,setStartBefore:setStartBefore,setStartAfter:setStartAfter,setEndBefore:setEndBefore,setEndAfter:setEndAfter,collapse:collapse,selectNode:selectNode,selectNodeContents:selectNodeContents,compareBoundaryPoints:compareBoundaryPoints,deleteContents:deleteContents,extractContents:extractContents,cloneContents:cloneContents,insertNode:insertNode,surroundContents:surroundContents,cloneRange:cloneRange,toStringIE:toStringIE});return self;}
Range.prototype.toString=function(){return this.toStringIE();};return Range;});